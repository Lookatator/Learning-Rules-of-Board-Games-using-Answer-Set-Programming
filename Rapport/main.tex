\documentclass[12pt,twoside]{report}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definitions for the title page
% Edit these to provide the correct information
% e.g. \newcommand{\reportauthor}{Timothy Kimber}

\newcommand{\reporttitle}{Learning Rules of Board Games using Answer Set Programming}
\newcommand{\reportauthor}{Luca Grillotti}
\newcommand{\supervisor}{Krysia Broda}
\newcommand{\degreetype}{Computing Science / Artificial Intelligence}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% load some definitions and default packages
\input{includes}

% redefine \VerbatimInput
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}%
{fontsize=\footnotesize,
 %
 frame=lines,  % top and bottom rule only
 framesep=2em, % separation between frame and text
 rulecolor=\color{Gray},
 %
 label=\fbox{\color{Black}data.txt},
 labelposition=topline,
 %
 %commandchars=\|\(\), % escape character and argument delimiters for
                      % commands within the verbatim
 commentchar=*        % comment character
}

% load some macros
\input{notation}

\date{September 2017}





\begin{document}

% load title page
\input{titlepage}


% page numbering etc.
\pagenumbering{roman}
\clearpage{\pagestyle{empty}\cleardoublepage}
\setcounter{page}{1}
\pagestyle{fancy}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Your abstract.
\end{abstract}

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%*%\section*{Acknowledgments}
%*%Comment this out if not needed.

\clearpage{\pagestyle{empty}\cleardoublepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%--- table of contents
\fancyhead[RE,LO]{\sffamily {Table of Contents}}
\tableofcontents 


\clearpage{\pagestyle{empty}\cleardoublepage}
\pagenumbering{arabic}
\setcounter{page}{1}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}

%TODO : au début de chaque section, ne pas oublier de récapituler ce de quoi je vais parler.

%TODO : parler du GDL (game describing language)

%TODO : parler des changements de code entre les .lp et .las dus aux syntaxes non acceptées ???

%TODO : give examples for everything (weak constraints, context dependant examples).

%TODO : proof that the 2-Player Game gives the right result (cf paper for Single player games)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{chapters/background}

\chapter{From Single Player Games to Two Player Games}

\section{Games under study}

This project focuses on three games: \textit{Five Field Kono}, \textit{Nine Men's Morris} and \textit{ASALTO}.

\bigskip

\emph{TODO : Describe origin, rules... for the three games}


\subsection{Five Field Kono}

%TODO : describe origin/ rules/ etc...


\subsection{Nine Men's Morris}

\subsection{ASALTO}

\section{Representing Two-Players games in ASP}

\subsection{Similarities and Differences with Single-Player games}

%TODO source single player game
Representing Two-Players games in ASP follows the same scheme as for Single-Player games \cite{thielscher2009answer}. However, the predicate \texttt{role/1} needs to be modified to include the \textit{color} of each player. And the predicate \texttt{legal/3} has to take into account the fact that this is a turn-based game: a player has the right to play if and only if it is his turn.

\bigskip

Also, we will consider that each \textit{cell} has a set of coordinates (represented by the function \texttt{coord}), and a \textit{state}. For example, if the red player has a red pawn on the cell of coordinates $(1,3)$ at time $4$, then its translation in ASP is: \texttt{holds(cell(coord(1,3),red),4).}

\bigskip

For the moment, we only have studied single-phase game (in the background chapter, and in \cite{thielscher2009answer}). But \textit{Nine Men's Morris} and \textit{ASALTO} are two-phases games: in both of them, players place their pawns before moving them. So we need to define a new predicate \texttt{phase/2} that will appear in the bodies of the rules that define \texttt{legal/3}

\subsubsection{How to describe a two-players-game in ASP}

\begin{enumerate}

\item First, we describe the two players, by using \texttt{role/2}, that takes the name of the player as first argument, and his color for its second argument. From now on, we will suppose the two players are respectively called \textit{player1} and \textit{player2}.  

\item Also, we add the following rule: \newline
\texttt{opponent(P1, P2) :- role(P1, C1), role(P2, C2), P1 != P2.}

\item Then we describe the game as if it was a single player game with only one phase \citep{thielscher2009answer} (we forget that this is a turn based game with one or more phases). In particular, we will have to define the predicates \texttt{holds/3}, \texttt{legal/3}, \texttt{terminal/1}, and \texttt{wins/2}. Moreover,  \texttt{legal(P,M,T)} should only rely on \texttt{holds(C,T)} (at time T \textit{only}), \texttt{role/2}, and \texttt{opponent/2} for the moment. That way, \texttt{legal/3} does not depend on the previous actions or on the previous states, but only on the current states of the game.

\item In each rule that defines \texttt{legal/3} (of the form \texttt{legal(Player, a(X), T)}), we add the following predicate in the body: \texttt{can\_play(Player, a, T)}. This predicate is true if an only if \texttt{Player} has the right to perform an action of type \texttt{a} at time \texttt{T}. 

\item We define the predicate \texttt{can\_play/3}. For instance, in the case of the single-phase turn-based game, \texttt{can\_play/3} can be defined in the following way:\newline
\texttt{turn(player1, 1). }\\
\texttt{turn(P1, T+1) :- time(T), turn(P2, T), opponent(P1, P2).}\\
\texttt{can\_play(Player, Action, T) :- turn(Player, T).}


\item If the game has more than one phase, we need to describe the mechanism of the phase. At time $T=1$, we are in the first phase:\newline
\texttt{phase(phase(1), 1).}\\
We also want a phase to continue before it has finished:\newline
\texttt{phase(phase(N), T+1) :- time(T), phase(phase(N), T), not finished(phase(N), T+1).}\\
And if it has finished at time $T$, we go to the next phase:\newline
\texttt{phase(phase(N+1), T) :- time(T), finished(phase(N),T).}

\smallskip

Then, we add \texttt{phase/2} in the definition of \texttt{can\_play/3}. For example, if the two players can only play an action of type $a$ in the first phase, and of type $b$ in the second one, then it is equivalent to: \newline
\texttt{can\_play(Player, a, T) :- turn(Player, T), phase(phase(1),T).}\\
\texttt{can\_play(Player, b, T) :- turn(Player, T), phase(phase(2),T).}

\item Finally, we need to write the rules that define \texttt{finished/2}. These rules mainly depend on the board game: for \textit{Nine Men's Morris}, we move to the second phase once both players have placed all their pawns, but in \textit{ASALTO}, the soldiers are already positioned at time $T=1$, and only one player has to place the officers. 
\end{enumerate}

\subsection{Example: Nine Men's Morris in ASP}

\subsubsection{Coordinate System}

To represent \textit{Nine Men's Morris}, ASP, we first need to define what are the coordinates of the different cells. It seems that the system has three layers with the second one inside of the first one, and the third one inside the first one. This will be our second coordinate. Besides, there are eight cells in each layer. We will suppose the cell at the top-left corner of the layer has its first coordinate equal to 1, and we increment this coordinate as we go through the layer clockwise (Figure \ref{fig:9MM_coord}).

\begin{figure}[h]
\centering
\includegraphics[width = 0.8\hsize]{9MM_coord.png}
\caption{Coordinates of the cells used in Nine Men's Morris}
\label{fig:9MM_coord}
\end{figure}

\subsubsection{Nine Men's Morris described in ASP}

Here, each item refers to the last subsection.

\begin{enumerate}
\item First, we define the players and their roles\\
\texttt{role(player1, red).\\
role(player2, blue).\\}

\item We also add the following rule:\\
\texttt{opponent(P1, P2) :- role(P1, C1), role(P2, C2), P1 != P2.}

\item Here, we describe the game as in \cite{thielscher2009answer}: \texttt{legal/3} only depends on the state of the game (\texttt{holds/2}) and the player that is playing. In other words, we do not take the turn-based aspect into account.

\smallskip

%TODO : Appendix
We will only introduce quickly the predicates that were defined in the ASP Program. You may refer to the complete ASP program (in Appendix ??) for further information. 

%TODO : graph of dependancies.
\begin{tabular}{|c|c|}
\hline 
predicate & description \\ 
\hline
\hline 
\texttt{holds/3} & \makecell{Describes the state of the game: which cells are empty, \\ and which ones contain a pawn of color red or blue.} \\ 
\hline 
\texttt{legal/3} & \makecell{Tells which action a player has the right to perform\\ at a specific time. For instance, \texttt{legal(P,remove\_pawn(C),T)}\\ is true if and only if there is a pawn of the opponent \\in \texttt{C} and this pawn is not in a mill\\ (but if all his pawns form mills, the player \texttt{P} can still remove it)} \\ 
\hline 
\texttt{adjacent/2} & \makecell{Two pairs of coordinates are adjacent if there is an \\ edge that links them (Figure \ref{fig:9MM_coord})} \\ 
\hline 
\texttt{is\_in\_mill/2} & \makecell{\texttt{is\_in\_mill(Coord,mill(Coord\_1, Coord\_2, Coord\_3),T)} \\is true if a player owns the mill \texttt{mill(Coord\_1, Coord\_2, Coord\_3)} \\ and if \texttt{Coord} is one of its three coordinates} \\ 
\hline 
\texttt{has\_mill/3} & \makecell{\texttt{has\_mill(P,Mill,T)} is true if Mill is a mill owned \\by P at time T. It helps to define \texttt{is\_in\_mill/2}} \\ 
\hline 
\texttt{all\_in\_mill/2} & \makecell{Tells if a player has all his pawns in mills} \\ 
\hline 
\texttt{terminal/1} & \makecell{Represents the end of the game (when a player has won).\\ Its only argument is the time \texttt{T}.} \\ 
\hline 
\texttt{wins/2} & \makecell{Tells which player has won and when. \\ A player wins if the other has 2 or less pawns on the board\\ or if the other player is not able to perform any move.}  \\ 
\hline 
\texttt{pawns\_on\_board/3} & \makecell{Counts the number of pawns for each player on the board \\at each time. }\\ 
\hline 
\texttt{able\_to\_play/2} & \makecell{Tells if a player is able to perform any action at a specific time.} \\ 
\hline 
\end{tabular} 

\item After having defined \texttt{legal/3} in the previous step, we add:
\begin{itemize}
\item \texttt{can\_play(Player, place\_pawn, T)} in the body of \texttt{legal(Player, \\place\_pawn(Coord), T) }
\item \texttt{can\_play(Player, move, T)} in the body of \texttt{legal(Player, move(Coord\_1, Coord\_2), T) }
\item \texttt{can\_play(Player, remove\_pawn, T)} in the body of \texttt{legal(Player, \\remove\_pawn(Coord), T) }
\end{itemize}

\item 
We will consider that there are two phases in this game. In the first phase, the players place their respective pawns on the board. And in the second, they have finished to place their pawns and they only move them. 

\bigskip

We suppose that \texttt{player1} starts:
\texttt{can\_play(player1, place\_pawn, 1).} 

\bigskip

To define \texttt{can\_play/3} at time \texttt{T+1} we need to have a closer look at the rules of the game:

\begin{itemize}
\item A player can remove a pawn  at time \texttt{T} if he created a new mill with his action at time \texttt{T-1} (in both phases):\\
\texttt{can\_play(P1, remove\_pawn, T+1) :- does(P1, Action, T), time(T), has\_new\_mill(P1, T+1), role(P1, C1),  phase(phase(1..2),T+1).}
\item Thus, a player can place a pawn if his opponent did not get a new mill with his last action, and if the game is in its first phase:\\
\texttt{can\_play(P1, place\_pawn, T+1) :- does(P2, Action, T), time(T), not has\_new\_mill(P2, T+1), opponent\_player(P1, P2), phase(phase(1),T+1).}
\item Also, a player can move a pawn at time \texttt{T+1} if his opponent did not get a new mill at the same time, and if the game is in its second phase:\\ 
\texttt{can\_play(P1, move, T+1) :- does(P2, Action, T), time(T), \\not has\_new\_mill(P2, T+1), opponent\_player(P1, P2), phase(phase(2),T+1).}
\end{itemize}

The definition of \texttt{has\_new\_meal/2} can be found in appendix ??

\item As there are more than one phase, we add the following definition of \texttt{phase/2} in the program (as explained in the last subsection):\\
\texttt{phase(phase(1), 1).}\\
\texttt{phase(phase(N), T+1) :- time(T), phase(phase(N), T),\\ not finished(phase(N), T+1).}\\
\texttt{phase(phase(N+1), T) :- time(T), finished(phase(N),T).}

\item Finally we define the predicate \texttt{finished/2}:
\begin{itemize}
\item The first phase is finished when both players do not have any pawn in their hands: \\
\texttt{finished(phase(1), T) :- time(T), has\_pawns(player1, 0, T), \\has\_pawns(player2, 0, T).}\\
Where \texttt{has\_pawns/3} counts the number of pawns that each player still has to place. Its complete definition may be found in appendix ??
%TODO : faire une recherche sur le latex pour les ?? et les remplacer
\item We suppose that the second phase never finishes (as there is no third phase). So we do not need to define \texttt{finished(phase(2), T)}. 
\end{itemize}

\end{enumerate}



% tableau: gauche -> règle en anglais, droite -> rule en ASP

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Learning rules for board Games}

\section{General Idea}

We observe people playing the game, and \\
if they do a valid action - positive example\\
if they do an action that is not legal - negative example\\

\bigskip

goal : learning legal/3 predicate (according to the structure of GDL)

\bigskip

source:  has been made in ILASP (paper reference)%(or concurrent) papers 

\bigskip

Learning predicate wins/2 ?

\section{Evaluation}

Evaluation at least for Five Field Kono.

\bigskip

\begin{tabular}{|c|c|c|}
\hline 
added example & hypothesis found & time (s) \\ 
\hline 
\hline
• & • & • \\ 
\hline 
• & • & • \\ 
\hline 
\end{tabular} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Learning strategies}

% 

For the moment, we only have implemented the \textit{tic-tac-toe} and the \textit{Field Field Kono} in python by using \texttt{pygame} (python library for video games).
%TODO : reference pygame
\smallskip

The idea would be to learn from the actions performed by a player to train our system by using ILASP. Then we could make him play against this trained system and continue to train it that way.

\section{First Method: maximize the chances of winning}
%TODO : Change title ?

\subsection{Learning Exception Structure}

Supposing we are at time $T=t$, we want the computer to induce a set of rules $H$ such that:
\begin{itemize}
\item There is a move $m$ such that for every answer set $A$ of $B\cup H,\:  does(player1, m, t)\in A$
\item For every answer set $A$ of $B\cup H$, for all move $m_1$ different from $m$, we have: $does(player1, m_1, t) \notin A$
\item $H$ also tries to take into account the possible future moves.
\end{itemize}

To reduce the hypothesis space, it would be interesting to focus only on \textit{exception structures}, which means we want $H$ to be of this form:
\[H=
\begin{Bmatrix}
\texttt{does(player1, move\_p1\_t0\_1, t).}\\
\texttt{does(player1, move\_p1\_t2\_1, t+2) :- \textcolor{red}{does(player2, move\_p2\_t1\_1, t+1)}.}\\
\texttt{does(player1, move\_p1\_t2\_2, t+2) :- not \textcolor{red}{does(player2, move\_p2\_t1\_1, t+1)}.} 
\end{Bmatrix}
\]
%TODO : A FAIRE avec le cours de Marek Sergot ???
In the set above, we will call "\textit{exception rule}" the second rule, and "\textit{general rule}" the third.

\begin{remark}
 The hypothesis space could also be extended so that it accepts two or more  exception rules.
\[H=
\begin{Bmatrix}
\texttt{does(player1, move\_p1\_t0\_1, t).}\\
\texttt{does(player1, move\_p1\_t2\_1, t+2) :-} &\texttt{\textcolor{red}{does(player2, move\_p2\_t1\_1, t+1)}.}\\
\texttt{does(player1, move\_p1\_t2\_2, t+2) :-} &\texttt{\textcolor{blue}{does(player2, move\_p2\_t1\_2, t+1)}.}\\
\texttt{does(player1, move\_p1\_t2\_3, t+2) :-} &\texttt{not \textcolor{red}{does(player2, move\_p2\_t1\_1, t+1)},}\\ &\texttt{not \textcolor{blue}{does(player2, move\_p2\_t1\_2, t+1)}.} 
\end{Bmatrix}
\]
\end{remark}

%TODO : Deuxième remarque pour expliquer comment prendre en compte ce qu'il se passe à t+4 ?

Moreover, the atoms in the exception rule must appear in the general rule (see the \textcolor{red}{red} and \textcolor{blue}{blue} atoms in the hypotheses above).

\bigskip

%TODO : good version of ILASP ?
With ILASP 3.1.0 it is possible add "bias constraints" to specify what kind of rule we want to learn. However it is not possible to add constraints on the whole set of rules induced. As a consequence, we cannot say that for every solution $H$ in $ILP_{LAS}(B,S_M,E^+,E^-)$, 
if there are $move\_p1\_t2\_1$ and $move\_p2\_t1\_1$ such that:
\\ $\texttt{"does(player1,move\_p1\_t2\_1,t+2) :- \textcolor{red}{does(player2,move\_p2\_t1\_1,t+1)}."}\in H$, 
then there is $move\_p1\_t2\_2$ such that:\\
$\texttt{"does(player1,move\_p1\_t2\_2,t+2):- not \textcolor{red}{does(player2,move\_p2\_t1\_1,t+1)}."}\in H$

\bigskip

The solution we used consists in using the ASPAL encoding in ILASP. With this encoding, we can add more flexible constraints for the hypothesis space.

\subsection{Example}

\paragraph{Current State of the Game}

Consider a tic-tac-toe game after the 4 following moves (represented in \ref{fig:ttt_ex}):\newline
\texttt{does(player1, fill(coord(2,2)),1).\\
does(player2, fill(coord(1,2)),2).\\
does(player1, fill(coord(1,1)),3).\\
does(player2, fill(coord(3,3)),4).}

\begin{figure}[h]
\centering
\includegraphics[width = 0.3\hsize]{ttt_example.png}
\caption{State of a tic-tac-toe game after 4 moves. The green player plays first (he is \texttt{player1}).}
\label{fig:ttt_ex}
\end{figure}

Here, we are the green player and we want to find a move such that we are sure to win in three moves.

\paragraph{Hypothesis space}

We use the following mode declaration:
\[ M=
\begin{Bmatrix} 
m1 :& \texttt{modeh(does(player1,\#move,5)).} \\ 
m2 :& \texttt{modeh(does(player1,\#move,7)).}\\
m3 :& \texttt{modeb(does(player2,\#move,6)).}\\
m4 :& \texttt{modeb(not does(player2,\#move,6)).}
\end{Bmatrix}
\]
%TODO : explain how a mode declaration works OR reference to an article to explain it

Moreover, we take the following hypothesis space:
\[ R_M=
\begin{Bmatrix}
\texttt{does(player1, X, 5).} \\ 
\texttt{does(player1, Z, 7) :-} & \texttt{does(player2, Y, 6).}\\
\texttt{does(player1, X, 7) :-}  & \texttt{not does(player2, Y, 6).}
\end{Bmatrix}
\]

So the top theory that we use for this example is:
\[ T=
\begin{Bmatrix}
\texttt{does(player1, X, 5) :-} & \texttt{legal(player1,X,5), rule((m1),(X)).} \\ 

\texttt{does(player1, Z, 7) :-} & \texttt{legal(player1, Z, 7), legal(player2, Y, 6), }\\ 
 & \texttt{does(player2, Y, 6), rule((m2,m3,2),(Z,Y)).} \\

\texttt{does(player1, X, 7) :-} & \texttt{legal(player1, X, 7), legal(player2, Y, 6), } \\
& \texttt{not does(player2, Y, 6), rule((m2,m4,2),(X,Y)).}
\end{Bmatrix}
\]
where we added the predicate \texttt{legal/3} to make the variables safe.

\bigskip

So now the hypothesis we want to learn with ILASP has the following form:
\[H=
\begin{Bmatrix}
\texttt{rule((m1),(\#move\_p1\_t0\_1)).}\\
\texttt{rule((m2,m3,2),(\#move\_p1\_t2\_1, \#move\_p2\_t1\_1))}.\\
\texttt{rule((m2,m4,2),(\#move\_p1\_t2\_2, \#move\_p2\_t1\_1))}.
\end{Bmatrix}
\]

\bigskip

We want $H$ to contain only one rule of each type: only one rule of the form\\ \texttt{rule((m1),(\#move\_p1\_t0\_1))} and so on... 
So we add some rules to make them unique:\newline
\texttt{rule1 :- rule((m1),(fill(coord(X,Y)))).}\\
\texttt{:- not rule1.}\\
\texttt{:- rule((m1),(fill(coord(X1,Y1)))), rule((m1),(fill(coord(X2,Y2)))), g(X1, Y1)< g(X2, Y2). }\\

\smallskip

The two first rules make \texttt{rule((m1),(\#move\_p1\_t0\_1))} appear at least once, and the last rule makes it appear at most once. We add similar rules for \texttt{rule((m2,m3,2), (\#move\_p1\_t2\_1, \#move\_p2\_t1\_1))} and \texttt{rule((m2,m4,2), (\#move\_p1\_t2\_2, \#move\_p2\_t1\_1))}.

\bigskip

Also, we added some constraints to reduce the computation time. For instance, if \texttt{rule((m1),(fill(coord(X,Y))))} is true, then \texttt{legal(player1,fill(coord(X,Y)),5)} must be true. So we add the following constraint:\newline
\texttt{:- rule((m1),(fill(coord(X,Y)))), not legal(player1,fill(coord(X,Y)),5).}

\bigskip

And if \texttt{rule((m2,m4,2),(fill(coord(X,Y)),fill(coord(Z,T))))} and \texttt{not does(player2, fill(coord(Z,T)), 6)} are true, then \texttt{legal(player1, fill(coord(X,Y)),7)} must be true unless \texttt{player2} plays in \texttt{coord(X,Y)} at time 6. Thus, we add the following constraint:\newline
\texttt{:- rule((m2,m4,2),(fill(coord(X,Y)),fill(coord(Z,T)))), not does(player2, fill(coord(Z,T)), 6),}
\texttt{ not legal(player1, fill(coord(X,Y)),7).}\newline
and we add this context-dependent example to the set of positive examples : \newline
$<<\{\texttt{wins(player2,8)}\},\emptyset>,\\ \{\texttt{:- rule((m2,m4,2),(fill(coord(X,Y)),fill(coord(Z,T)))),} \\ \texttt{not does(player2, fill(coord(X,Y)), 6).}\}>$
%TODO : change fonts to textt in partial interpretations

\smallskip

With this example, we are sure that there will be at least one answer set where \texttt{player2} plays in \texttt{coord(X,Y)}.


\paragraph{Declaring the examples}

First of all, we want the first player to win in two moves all the time. So there is no answer set that does not contain \texttt{wins(player1,8)}. Thus, we take : $E^-=\{<\emptyset,\{\texttt{wins(player1,8)}\}>\}$.

\bigskip

For the positive examples, we only need to take the one given in the previous paragraph. The \texttt{wins(player2,8)} in it is optional but it reduces the computation time from 11 seconds to 1 second.

\paragraph{Evaluation}

%TODO : to complete

\subsection{Finding a move in the middle of a game}

We are only able to look two moves ahead, so we cannot predict how to win a game if we are not very close to the end. It would be a good idea to define what a good state is (or to make ILASP learn it). And after that, it could be possible to choose a state at time $t$ that maximizes the chances of reaching a good state at time $t+2$.

\bigskip

For instance, if we consider the game represented in figure \ref{fig:graph_game}, where \texttt{player1} plays at times $t$ and $t+2$ and \texttt{player2} plays at time $t+1$. 

\smallskip

We want to maximize the probability of reaching a good state at $t+2$. So we choose $a(x)$ such that $\#\{b(y)|legal(b(y))\wedge\:\left( b(y) \implies \exists \:c(z) \:;\: legal(c(z)) \wedge good\_state(state\_c(z)) \right)\}$ is maximal, which is $a(1)$ in this example.

\begin{figure}[h]
\centering
\includegraphics[width = 0.8\hsize]{graph_game.png}
\caption{Desription of a graph game with its states and the actions to perform to go from one state to another. The blue player (that plays at times $t$ and $t+2$) is \texttt{player1}. The states in purple are the good states.}
\label{fig:graph_game}
\end{figure}

\section{Second Method: recognize preferred moves and states}

Goal: learn the preferences of the player by using Weak Constraints.

\subsection{Learning what kind of action the player prefers}

\emph{When we have the choice of the kind of action like in Five Field Kono : Learning  direction, up\_right, down\_right... }

%TODO : not very interesting isn't it ? cos' it could be done just by counting them.

\subsection{Discover the sates of the board that the player chooses}

Talk about the the drawbacks of last subsection: does not give enough information. So now we learn what kind of configuration the player prefers in a game. 

%TODO : parler des limitations de la section précédente.
% certes on pourrait lier les deux: does() :- holds(), holds(),...
% Mais serait trop computationally expensive ???

\subsubsection{How to represent patterns}

How to represent patterns, how to combine them. Example of Five Field Kono

% 

\subsubsection{Learning preferred patterns}

Test results with program, with time results.

Problem: one simple pattern can cover many more complex patterns

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\chapter{Evaluation}

TODO : or maybe a part evaluation in each of the previous chapters

\chapter{Conclusions and Future work}


\begin{comment}

\chapter{Progress}

\section{Two-Players games}

\subsection{Representing Two-Players games in ASP}

We only need to change a few things to adapt the rules in single-player games for two-players games:
\begin{itemize}
\item First of all, we create two roles instead of one:\\ \texttt{role(player1).}\\
\texttt{role(player2).}
\item Then we replace \texttt{player} in every rule by the variable \texttt{P}, and we add \texttt{role(P)} at the end of each rule.
\item Besides, only one move is allowed at each time step:\\
\texttt{1\{does(P,M,T):role(P),move\_domain(M)\}1 :- not terminated(T).}\\
\texttt{move\_domain(go(left))}.\\
\texttt{move\_domain(go(right))}.

\item Finally, a player cannot play twice:\\
\texttt{:- does(P,M1,T), does(P,M2,T+1).}

\end{itemize}

\subsection{Games under study}

This project focuses on three games: \textit{Five Field Kono}, \textit{Nine Men's Morris} and \textit{ASALTO}.

%TODO : give references

\smallskip

For the moment, we have only tried to study how to learn a strategy on a very simple game (with a small number of possible states): the \textit{tic-tac-toe}. Afterwards, we will try to extend what we have done on \textit{tic-tac-toe} to \textit{Five Field Kono}.

\smallskip

Moreover, we have represented these four games in ASP.

\section{Finding/Learning a strategy}

We found several ways of thinking about how to learn a strategy:
\begin{itemize}
\item The first one consists in trying to find a move such that: whatever the second player does the next turn (or his 2 or 3 next turns), the first player can still win. This method seems very similar to the \textit{minimax} algorithm. 
\item We could also study several games played by two players, and try to make hypotheses about what to do in which circumstances. 
\item It is possible to imagine a mix between the two previous methods: the second one tells us what are the good states, and the first method gives us a move so that we can reach a good state for sure (whatever the second player does).
\end{itemize}

For the moment, we have only studied the first method.

%TODO : give references (minimax)
%TODO : parler des inconvénients de chaque méthode.

\subsection{Planning moves}

\subsubsection{Basic method}

In \textit{tic-tac-toe}, we initialized the game with 4 specific moves already done. If we restrict the hypothesis space by not allowing negation by failure nor constraints, ILASP can find some (ground) hypotheses of the form:\\
\texttt{does(player1,fill(cell(x)),5). \% at time T=5 } \\
\texttt{does(player1,fill(cell(y)),7) :- does(player2,fill(cell(z)),6).}\\
that make \texttt{player1} win. 

\smallskip

For this, we only need to specify that the program has at least an answer set: \texttt{\#pos(\{\},\{\})}, and that \texttt{player1} wins in every answer set: \texttt{\#neg(\{\},\{wins(player1)\})}.

\subsubsection{Problem with negation by failure}



\subsubsection{Solution Found for the Graph Games}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%*%\chapter{Experimental Results}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{comment}


%% bibliography
\bibliographystyle{abbrv}
\bibliography{exemple}

\appendix


%TODO : make it clearer with stuff like this to present the predicates:
%%%%%%%%%%%%%%%%%%%
% COUCOU%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
\chapter{Nine Men's Morris described in ASP}

\VerbatimInput[label=\fbox{\color{Black}Nine Men's Morris}]{9MM.lp}

\end{document}
